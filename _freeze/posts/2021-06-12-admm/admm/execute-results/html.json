{
  "hash": "d12e824e445597dc5d36c605e22c0f5c",
  "result": {
    "markdown": "---\ntitle: \"ADMM example\"\ndescription: |\n  vscode에서 quarto와 파이썬 사용하기 \nauthor: \"Don Don\"\ndate: \"2022-06-22\"\ncategories: [python]\nimage: \"https://quarto.org/docs/tools/images/vscode-render.png\"\n---\n\n\n\n## scaled dual ADMM algorithm\n\n-   Given x, z and \\mu, \\rho to some initial value.\n\n-   Repeat:\n\n    -   $x:= \\arg\\max_{x}(f(x) + \\frac{\\rho}{2}\\|Ax+Bz-c+\\mu\\|_2^2)$\n    -   $x:= \\arg\\max_{x}(g(z) + \\frac{\\rho}{2}\\|Ax+Bz-c+\\mu\\|_2^2)$\n    -   $\\mu:= \\mu + (Ax + Bz - c)$\n    -   Stopping criterion : quit $\\|r\\|_2<\\epsilon$ and $\\|s\\|_2<\\epsilon$ <br><br><br>\n\n### Stopping criterion\n\nWe can define the primal and dual residuals in ADMM at step k+1.\\\n\\* Primal residuals : $r^{k+1} = Ax^{k+1} + Bz^{k+1} - c$\\\n\\* Dual residuals : $s^{k+1} = \\rho A^TB(z^{k+1} - z^k)$\\\n\nTherefore stopping criterion satisfies that $\\|r\\|_2$ and $\\|s\\|_2$ are smaller than any $\\epsilon$\n\n<br><br>\n\n### Lasso example\n\n\n$$\n\\begin{equation*}\n\\begin{aligned}\n& \\underset{\\beta}{\\text{minimize}}\n& & \\sum_{i=1}^n (y_i - \\beta_0 - x_i^t\\beta)^2 + \\lambda \\sum_{j = 1}^p |\\beta_j| \\\\\n\\end{aligned}\n\\end{equation*}\n$$\n\n\n$\\Leftrightarrow$\n\n\n$$\n\\begin{equation*}\n\\begin{aligned}\n& \\underset{\\beta}{\\text{minimize}}\n& & f(\\beta) + f(z) \\\\\n& \\text{subject to}\n& & I\\beta - IZ = 0\n\\end{aligned}\n\\end{equation*}\n$$\n\n\n\\\n\n\n$$\n\\begin{align}\nr = I\\beta - IZ \\newline\nL_\\rho(\\beta, z, v) &= f(\\beta) + g(z) + v^tr + \\frac{\\rho}{2}||r||_2^2 \\newline\n                    &= f(\\beta) + g(z) + \\frac{\\rho}{2}||r+\\frac{1}{\\rho}v||_2^2 - \\frac{\\rho}{2}||v||_2^2 \\newline\n                    &= f(\\beta) + g(z) + \\frac{\\rho}{2}||r+\\mu||_2^2 - constant_v, \\quad \\mu = \\frac{1}{\\rho}v \n\\end{align}\n$$\\\n\n$$\n\\begin{align}\n\\beta^{k+1} &:= \\operatorname*{argmin}_\\beta (f(\\beta) + \\frac{\\rho}{2}||I\\beta - IZ^k + \\mu^k||_2^2) \\newline\n            &= \\operatorname*{argmin}_\\beta (y-X\\beta)^t(y-X\\beta) + \\frac{\\rho}{2}||I\\beta - IZ^k + \\mu^k||_2^2) \\newline\n            &\\Rightarrow -2X^ty + 2X^tX\\beta + \\rho\\beta - \\rho Z^k +\\rho\\mu^k = 0 \\newline\n            &\\Leftrightarrow (2X^tX + \\rho I)\\beta = 2X^ty + \\rho(Z^k - \\mu^k) \\newline\n            &\\therefore \\beta^{k+1} = (2X^tX + \\rho I)^{-1}(2X^ty + \\rho(Z^k - \\mu^k))\n\\end{align}\n$$\n\n\n\\\n\n\n$$\n\\begin{align}\n\\beta^{k+1} &:= \\operatorname*{argmin}_\\beta (f(\\beta) + \\frac{\\rho}{2}||I\\beta - IZ^k + \\mu^k||_2^2) \\newline\n            &= \\operatorname*{argmin}_\\beta (y-X\\beta)^t(y-X\\beta) + \\frac{\\rho}{2}||I\\beta - IZ^k + \\mu^k||_2^2) \\newline\n            &\\Rightarrow -2X^ty + 2X^tX\\beta + \\rho\\beta - \\rho Z^k +\\rho\\mu^k = 0 \\newline\n            &\\Leftrightarrow (2X^tX + \\rho I)\\beta = 2X^ty + \\rho(Z^k - \\mu^k) \\newline\n            &\\therefore \\beta^{k+1} = (2X^tX + \\rho I)^{-1}(2X^ty + \\rho(Z^k - \\mu^k))\n\\end{align}\n$$\n\n\n\\\n\nThe prox operatior for $g(z) = \\lambda||z||_1$\n\n\n$$\n\\begin{align}\nprox_{\\lambda, g}(z) &= \\operatorname*{argmin}_v (\\lambda||z||_1 + \\frac{1}{2}||z-v||_2^2) \\newline\n                     &= \\operatorname*{argmin}_v (||v||_1 + \\frac{1}{2\\cdot \\lambda}||z-v||_2^2) \\newline\n                     &\\therefore \\operatorname*{argmin}_{v_i} (\\frac{1}{2}(v_i - z_i)^2 + \\lambda|v_i|) \n\\end{align}\n$$\n\n\n\\\n\n\n$$\n\\begin{align}\nZ^{k+1} &:= \\operatorname*{argmin}_Z (g(Z) + \\frac{\\rho}{2}||I\\beta^{k+1} - IZ + \\mu^k||_2^2) \\newline\n            &= \\operatorname*{argmin}_Z (g(Z) + \\frac{\\rho}{2}||\\beta^{k+1} + \\mu^k - Z) ||_2^2 \\newline\n            &= \\operatorname*{argmin}_Z (g(Z) + \\frac{1}{2\\cdot \\frac{1}{\\rho}}||\\beta^{k+1} + \\mu^k - Z) ||_2^2 \\newline\n            &\\therefore prox_{\\frac{1}{\\rho}, g}(\\beta^{k+1} + \\mu^k)\n\\end{align}\n$$\n\n\n\\\n\n-   Given $\\beta$, $z$, $\\mu$, $\\rho$ to some initial value\n\n-   Repeat:\n\n    -   $\\therefore \\beta^{k+1} = (2X^tX + \\rho I)^{-1}(2X^ty + \\rho(Z^k - \\mu^k))$\n    -   $\\therefore Z^{k+1} = prox_{\\frac{1}{\\rho}, g}(\\beta^{k+1} + \\mu^k)$\n    -   $\\mu^{k+1}:= \\mu^k + (\\beta^{k+1} - Z^{k+1})$\n    -   Stopping criterion : quit $\\|r\\|_2<\\epsilon$ and $\\|s\\|_2<\\epsilon$\n\n<br>\n\n-   prime resdual : $r^{k+1} = \\beta^{k+1} - z^{k+1}$\n-   dual resdual : \\$s\\^{k+1} = -\\rho (z\\^{k+1} - z\\^k) \\$\n\n\\\n\n## R code \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnll <- function(X, Y, beta) {\n                A <- Y - X %*% beta\n                loglike <- crossprod(A)\n                return(loglike)\n}\n\n# Proximal operator\nprox.l1 <- function(u, lambda) {\n                uhat <- abs(u) - lambda\n                prox <- sign(u) * pmax(rep(0, length(u)), uhat)\n                return(prox)\n}\n\nl2norm <- function(x) sqrt(sum(x^2))\n\n\nADMM <- function(X,Y,rho=5,lambda=.1,iter=100, eps = 0.0001){\n                \n                n <- nrow(X)\n                p <- ncol(X)\n                \n                beta <- matrix(0, nrow=iter, ncol=p) \n                beta[1,] <- rep(0, p)\n                \n                obj <- rep(0, iter)\n                obj[1] <- nll(X, Y, beta[1,]) + lambda * sum(abs(beta[1,]))\n                \n                z <- matrix(0, nrow=iter, ncol=p)\n                v <- rep(0, p)     \n                \n                invmat <- solve(2*crossprod(X) + diag(rho, p))\n                \n                s <- 0    \n                r <- 0    \n                t <- 0\n                \n                for (t in 2:iter){\n                                \n                                beta[t,] <- invmat %*% (2*crossprod(X, Y) + rho * (z[t-1,]-v))\n                                z[t,] <- prox.l1(beta[t,] + v, lambda/rho)\n                                v <- v + beta[t,] - z[t,]\n                                obj[t] <- nll(X, Y, beta[t,]) + lambda * sum(abs(beta[t,]))\n                                \n                                r <- beta[t,] - z[t,]\n                                s <- -rho * (z[t,] - z[t-1,])\n                                \n                                r.norm <- l2norm(r)\n                                s.norm <- l2norm(s)\n                                \n                                if (r.norm < eps & s.norm < eps) {\n                                                break\n                                }\n                }\n                beta <- beta[-c(t+1:iter),]\n                obj <- obj[-c(t+1:iter)]\n                result <- list(\"beta.hat\" = beta[nrow(beta),], \"beta\"=beta, \"objective\"=obj, \"iter\"=t)\n                return(result)\n}\n\nx <- cbind(1, matrix(rnorm(1000*4), ncol = 4))\nbeta <- c(1.4, -2, -3, 4, 5)\n\neps <- rnorm(1000*1)　\ny <- x%*%beta + eps \n\nADMM(X = x, Y = y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$beta.hat\n[1]  1.394049 -1.978164 -2.981449  3.974279  4.951313\n\n$beta\n         [,1]      [,2]      [,3]     [,4]     [,5]\n[1,] 0.000000  0.000000  0.000000 0.000000 0.000000\n[2,] 1.390489 -1.973194 -2.974225 3.964208 4.938941\n[3,] 1.393988 -1.978098 -2.981382 3.974205 4.951232\n[4,] 1.394048 -1.978164 -2.981449 3.974279 4.951313\n[5,] 1.394049 -1.978164 -2.981449 3.974279 4.951313\n\n$objective\n[1] 55613.3328   980.2120   979.8707   979.8707   979.8707\n\n$iter\n[1] 5\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}